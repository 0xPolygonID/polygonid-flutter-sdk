/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package github.com/iden3/go_iden3_core_clib/cmd/libiden3core */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h> /* for ptrdiff_t below */

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 3 "main.go"

#include <stddef.h>
#include <string.h>
#include <stdlib.h> // for C.free
#include <stdbool.h> // for bool
#include <time.h> // for time_t

typedef enum
{
	IDENBIGINT_OK,
	IDENBIGINT_PARSE_FAILED,
} IDENBigIntStatus;

typedef struct _IDENBigInt {
	unsigned char* data;
	size_t data_len;
	IDENBigIntStatus status; // 0 in case of success
	char *error_msg;
} IDENBigInt;

typedef enum
{
	IDENTREEENTRY_OK,
	IDENTREEENTRY_OUT_OF_MEMORY,
	IDENTREEENTRY_CREATE_CLAIM_ERROR,
	IDENTREEENTRY_EXTRACT_CLAIM_ERROR,
} IDENtreeEntryStatus;

typedef struct _IDENTreeEntry
{
	unsigned char *data;
	size_t data_len;
	IDENtreeEntryStatus status; // 0 in case of success
	char *error_msg;
} IDENTreeEntry;

typedef enum
{
	IDENTMERKLETREE_OK,
	IDENTMERKLETREE_CREATE_ERROR,
} IDENmerkleTreeStatus;

typedef struct _IDENmerkleTree
{
	uintptr_t handle;
	IDENmerkleTreeStatus status;
	char *error_msg;
} IDENmerkleTree;

typedef enum
{
	IDENSTATUSCODE_OK,
	IDENSTATUSCODE_ENTRY_STATUS_INCORRECT,
	IDENSTATUSCODE_ENTRY_LENGTH_INCORRECT,
	IDENSTATUSCODE_CANT_ADD_ENTRY_TO_MERKLETREE,
} IDENstatusCode;

typedef struct _IDENstatus
{
	IDENstatusCode status;
	char *error_msg;
} IDENstatus;

typedef enum
{
	IDENPROOFSTATUS_OK,
    IDENPROOFSTATUS_MERKLETREE_INCORRECT,
    IDENPROOFSTATUS_INDEX_HASH_INCORRECT,
    IDENPROOFSTATUS_GENERATE_PROOF_ERROR,
	IDENPROOFSTATUS_OUT_OF_MEMORY,
} IDENProofStatus;

typedef struct _IDENProof
{
	IDENProofStatus status; // 0 in case of success
	char *error_msg;
	bool existence;
	unsigned char **siblings; // array of pointers to hash — 32 byte arrays
	size_t siblings_num; // number of hashes in hashes
	unsigned char *auxNodeKey; // 32 byte array
	unsigned char *auxNodeValue; // 32 byte array
} IDENProof;

typedef enum
{
	IDENHASHSTATUS_OK,
	IDENHASHSTATUS_TREEENTRY_INCORRECT,
	IDENHASHSTATUS_GENERATE_HASH_ERROR,
} IDENHashStatus;

typedef struct _IDENHash
{
	IDENHashStatus status;
	char *error_msg;
	unsigned char *data;
	size_t data_len;
} IDENHash;

typedef enum
{
	IDENCLAIMSTATUS_OK,
	IDENCLAIMSTATUS_CREATE_ERROR,
	IDENCLAIMSTATUS_INCORRECT_HANDLE,
	IDENCLAIMSTATUS_SET_ERROR,
} IDENClaimStatus;

typedef struct _IDENClaim
{
	uintptr_t handle;
	IDENClaimStatus status;
	char *error_msg;
} IDENClaim;

extern unsigned char **iden_alloc_hashes(int n);

extern void
iden_set_hash_idx(unsigned char **hashes, unsigned char *hash, int idx);

extern void
iden_free_hashes(unsigned char **hashes, size_t num);

extern const size_t hashLen;

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef __SIZE_TYPE__ GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif

extern char* reverse(char* in);

// Return pointer to IDENTreeEntry struct.
// When tree entry is not needed anymore, it should be freed with
// `IDENFreeTreeEntry` function.
extern IDENTreeEntry* IDENauthClaimTreeEntry(unsigned char* schemaHash, IDENBigInt* keyX, IDENBigInt* keyY, long long unsigned int revNonce);
extern IDENHash* IDENTreeEntryIndexHash(IDENTreeEntry* res);
extern void IDENFreeHash(IDENHash* res);
extern void IDENFreeTreeEntry(IDENTreeEntry* res);
extern IDENmerkleTree* IDENnewMerkleTree(int maxLevels);

// Free memory used by merkle tree
extern void IDENFreeMerkleTree(IDENmerkleTree* mt);
extern IDENstatus* IDENmerkleTreeAddClaim(IDENmerkleTree* mt, IDENTreeEntry* treeEntry);

// Return merkle tree root as 32 byte array. Should be freed after usage
// If merkle tree is in bad status, return nil
extern unsigned char* IDENmerkleTreeRoot(IDENmerkleTree* mt);
extern IDENProof* IDENmerkleTreeGenerateProof(IDENmerkleTree* mt, IDENHash* indexHash);
extern void IDENFreeProof(IDENProof* proof);

// mtHash is a pointer to merkle tree hash — 32 bytes array
// Returns ID — pointer to 31 bytes array
extern unsigned char* IDENidGenesisFromIdenState(unsigned char* mtHash);
extern void IDENFreeStatus(IDENstatus* status);
extern IDENBigInt* IDENBigIntFromString(char* i);
extern void IDENFreeBigInt(IDENBigInt* bi);
extern IDENClaim* IDENNewClaim(unsigned char* schemaHash);
extern void IDENClaimSetValueDataInt(IDENClaim* c, IDENBigInt* slotA, IDENBigInt* slotB);
extern void IDENClaimSetIndexDataInt(IDENClaim* c, IDENBigInt* slotA, IDENBigInt* slotB);
extern void IDENClaimSetRevocationNonce(IDENClaim* c, long long unsigned int revNonce);
extern void IDENClaimSetExpirationDate(IDENClaim* c, time_t t);
extern IDENTreeEntry* IDENClaimTreeEntry(IDENClaim* c);
extern void IDENFreeClaim(IDENClaim* claim);

#ifdef __cplusplus
}
#endif
