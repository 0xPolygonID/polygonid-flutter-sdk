#include <stdio.h>
#include <stdlib.h>
#include "../ios/libarduios-darwin-arm64.h"

int
main(int argc, char *argv[]) {
  unsigned char schemaHash[16] = {0x52, 0xFD, 0xFC, 0x07, 0x21, 0x82, 0x65, 0x4F, 0x16, 0x3F, 0x5F, 0x0F, 0x9A, 0x62, 0x1D, 0x72};
  
  struct Int keyX;
  // X = 15468939102716291673743744296736132867654217747684906302563904432835075522918
  unsigned char XVal[32] = {0x66, 0x41, 0x8C, 0x4D, 0x7F, 0x25, 0x2C, 0xC2, 0x3E, 0xDF, 0x63, 0xE4, 0x5D, 0xBD, 0x98, 0x45, 0x57, 0xD8, 0xA4, 0xDA, 0x41, 0x2C, 0xC8, 0x12, 0x64, 0x16, 0xE0, 0xA4, 0xF8, 0x1B, 0x33, 0x22};
  keyX.value = XVal;
  keyX.len = 32;
  
  struct Int keyY;
  // Y = 10564057289999407626309237453457578977834988122411075958351091519856342060014
  unsigned char YVal[32] = {0xEE, 0xCB, 0x05, 0xCF, 0xDD, 0x4F, 0x4D, 0x8A, 0x7B, 0xC1, 0x00, 0xD9, 0x60, 0x62, 0xC0, 0xBA, 0x00, 0x0F, 0x98, 0xBC, 0x6D, 0x99, 0xEA, 0xB2, 0x54, 0xEC, 0x46, 0xC3, 0x66, 0x0B, 0x5B, 0x17};
  keyY.value = YVal;
  keyY.len = 32;

  unsigned long long revNonce = 13260572831089785859ull;

  IDENTreeEntryResult *entryRes = IDENauthClaimTreeEntry(schemaHash, keyX, keyY, revNonce);
  if (entryRes == NULL) {
	printf("unable to allocate tree entry\n");
	return 1;
  };

  if (entryRes->status != IDENTREEENTRY_OK) {
	printf("error creating tree entry, code %i", entryRes->status);
	if (entryRes->error_msg != NULL) {
	  printf(", error message: %s", entryRes->error_msg);
	};
	printf("\n");
	return 1;
  };

  if (entryRes->data_len != 8 * 32) {
	printf("unexpected data length: %lu\n", entryRes->data_len);
	return 1;
  };

  // print data we get from auth claim creation
  if (0) {
	for (int i = 0; i < 8; i++) {
	  printf("%i:", i);
	  for (int j = 0; j < 32; j++) {
		printf(" %02X", entryRes->data[32*i+j]);
	  };
	  printf("\n");
	};
  };

  // expected tree entry
  unsigned char expected[] = {
	0x52, 0xFD, 0xFC, 0x07, 0x21, 0x82, 0x65, 0x4F, 0x16, 0x3F, 0x5F, 0x0F, 0x9A, 0x62, 0x1D, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x41, 0x8C, 0x4D, 0x7F, 0x25, 0x2C, 0xC2, 0x3E, 0xDF, 0x63, 0xE4, 0x5D, 0xBD, 0x98, 0x45, 0x57, 0xD8, 0xA4, 0xDA, 0x41, 0x2C, 0xC8, 0x12, 0x64, 0x16, 0xE0, 0xA4, 0xF8, 0x1B, 0x33, 0x22,
	0xEE, 0xCB, 0x05, 0xCF, 0xDD, 0x4F, 0x4D, 0x8A, 0x7B, 0xC1, 0x00, 0xD9, 0x60, 0x62, 0xC0, 0xBA, 0x00, 0x0F, 0x98, 0xBC, 0x6D, 0x99, 0xEA, 0xB2, 0x54, 0xEC, 0x46, 0xC3, 0x66, 0x0B, 0x5B, 0x17,
	0x03, 0x7C, 0x4D, 0x7B, 0xBB, 0x04, 0x07, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  };

  int cmpRes = memcmp(expected, entryRes->data, entryRes->data_len);

  if (cmpRes != 0) {
	IDENFreeTreeEntryResult(entryRes);
	printf("unexpected tree etnry\n");
	return 1;
  };
  printf("generated Tree Entry IS CORRECT\n");


  /*
   * Test merkle tree
   */

  IDENmerkleTree *mt = IDENnewMerkleTree(40);
  if (mt == NULL) {
	printf("unable to allocate merkle tree\n");
	IDENFreeTreeEntryResult(entryRes);
	return 1;
  };

  if (mt->status != IDENTMERKLETREE_OK) {
	printf("error creating merkle tree, code %i", mt->status);
	if (mt->error_msg != NULL) {
	  printf(", error message: %s", mt->error_msg);
	};
	printf("\n");
	IDENFreeMerkleTree(mt);
	IDENFreeTreeEntryResult(entryRes);
	return 1;
  }

  printf("merkle tree successfuly created\n");

  IDENstatus *addStatus = IDENmerkleTreeAddClaim(mt, entryRes);

  // tree entry is not needed anymore
  IDENFreeTreeEntryResult(entryRes);

  if (addStatus == NULL) {
	IDENFreeMerkleTree(mt);
	printf("unable to allocate result to add entry to merkle tree");
	return 1;
  }

  if (addStatus->status != IDENSTATUSCODE_OK) {
	printf("error add entry to merkle tree, code %i", addStatus->status);
	if (addStatus->error_msg != NULL) {
	  printf(", error message: %s", addStatus->error_msg);
	};
	printf("\n");
	IDENFreeMerkleTree(mt);
	IDENFreeStatus(addStatus);
	return 1;
  };
  
  // addStatus is not needed anymore
  IDENFreeStatus(addStatus);
  printf("add status successfuly freed\n");

  unsigned char *mtRoot = IDENmerkleTreeRoot(mt);
  if (mtRoot == NULL) {
	IDENFreeMerkleTree(mt);
	printf("unable to get merkle tree root\n");
	return 1;
  };

  printf("Root:");
  for (int i = 0; i < 32; i++) {
	printf(" %02X", mtRoot[i]);
  };
  printf("\n");

  unsigned char expectedRoot[] = {
	0x49, 0x18, 0x67, 0x79, 0x66, 0x47, 0x21, 0xf1,
	0x2e, 0xd2, 0xeb, 0xea, 0x79, 0xab, 0x80, 0x9c,
	0xe7, 0x50, 0xb4, 0x6a, 0x39, 0xab, 0x7e, 0x6f,
	0xb9, 0x4e, 0xe5, 0xe5, 0x25, 0x3b, 0x2b, 0x1f};
  cmpRes = memcmp(expectedRoot, mtRoot, 32);
  if (cmpRes == 0) {
	printf("Generated Tree Root IS CORRECT\n");
  };

  free(mtRoot);
  printf("tree root successfuly freed\n");
  
  IDENFreeMerkleTree(mt);
  printf("merkle tree successfuly freed\n");

  return 0;
}
